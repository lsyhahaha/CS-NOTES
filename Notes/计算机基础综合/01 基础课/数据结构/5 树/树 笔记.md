[TOC]



# 5.1 树的基本概念

### 5.1.1 树的定义

**概念：**

**特点：**



### 5.1.2 基本术语

- 祖先、子孙、双亲、孩子、兄弟

- 度

  树中一个节点的孩子个数称为结点的度，树中结点的最大度称为树的度。

  

- 分支结点、叶子结点（终端结点）

- 深度、高度、层次

- 有序数、无序树

- 路径、路径长度（两结点所经过边的个数）

- 森林





### 5.1.3 树的性质

- 树中的结点数等于所有结点的度数之和+1；

  ![image-20230805230833980](https://cdn.jsdelivr.net/gh/lsyhahaha/Mytypora/img/202308052308187.png)

- 度为m的树第i层上至多有m的。。。。。。。。。。。。

- ![image-20230805230922306](https://cdn.jsdelivr.net/gh/lsyhahaha/Mytypora/img/202308052309431.png)



### 5.1.4 课后习题（p127）

小题：

- 4.树的路劲长度是从树到每个结点的路径长度的（总和）；
- 5.对于一颗具有n个结点、度为4的树来说，（高度至多为n-3）。 【画图就很清晰了】
- 7.**结点数 = 所有度数之和 + 1**              **n0 + n1 + ... = 0 + 1*n1 + 2*n2 ....   + 1**



大题：

- 1 【用树的性质④】

  ![image-20230805230945510](https://cdn.jsdelivr.net/gh/lsyhahaha/Mytypora/img/202308052309625.png)

- 2 【简单题】 【结点数 = 所有度数之和 + 1】

- 3 【不会这样考】【废题】【也用第二题的性质】

### 查漏补缺：

日期：  知识点： 第几轮复习：







# 5.2 二叉树的概念

### 5.2.1 二叉树的定义及其主要特性

###### ①二叉树的定义

**概念：**p129



**二叉树与度为2的有序树的区别：**

1. 结点度数限制：

   - 度为2的有序树至少有三个结点，而二叉树可以为空；

   - 二叉树：每个节点最多有两个子节点，分别称为左子节点和右子节点。因此，每个节点的度数可以是0、1或2。
   - 度为2的有序树：每个节点最多有两个子节点，而且度为2的有序树通常会要求左子节点的值小于该节点，右子节点的值大于该节点，这样才能保证树的有序性。它的特点是可以用来实现快速搜索和排序。

2. 有序性要求：

   - 二叉树：通常没有特定的有序性要求，可以是完全无序的。
   - 度为2的有序树：节点的有序性是树的重要特点之一。在一个度为2的有序树中，对于每个节点来说，其左子节点的值必须小于该节点的值，右子节点的值必须大于该节点的值。

3. 查找和排序：

   - 二叉树：由于没有有序性要求，二叉树在查找和排序方面的效率可能相对较低。
   - 度为2的有序树：由于有序性的限制，度为2的有序树可以实现快速的搜索和排序，特别是针对有序数据的查找。



###### ②几种特殊的二叉树



###### ③二叉树的性质



### 5.2.2 二叉树的存储结构

###### ①顺序存储结构

###### ②链式存储结构



### 5.2.3 课后习题（p132~134）

小题：

- 1 在完全二叉树中，若一个结点没有左孩子，则它必是叶子结点；
- 2 【A画图比较清晰】【D 左孩子不一定存在】
- 4 【这种选择题可以采用举例法】【画图法，找到符合这种状态的树的结构和规律】
- 7  【树的性质：n个结点和m叉树的最小高度】 【二叉树的性质：具有n个结点的二叉树的最大高度为n】 
- 14  【搞清楚完全二叉树的性质之后这题就很简单了】【完全二叉树的性质：度为1的结点要么为1，要么为0】 【完全二叉树：n2 = n0-1】
- 18 【有难度，一下子想不到解法】【答案是特殊值法求解的】
- 23



大题（没有真题）：

- 1

- 2

- 3

- 4

- 5 已知一棵二叉树按顺序存储结构进程存储，设计一个算法，求编号分别为i和j的两个结点的最近的公共祖先的值。

  ```
  算法思想：
  对于按顺序存储结构的二叉树，编号为i和j的节点的最近公共祖先的值可以通过以下步骤来计算：
  
  计算节点i和节点j的层级（深度）。
  从根节点开始，向上遍历到两个节点的最近公共祖先。
  算法步骤如下：
  
  获取节点i和节点j在顺序存储结构中的索引位置index_i和index_j，索引从0开始。
  计算节点i和节点j的层级level_i和level_j。节点在顺序存储结构中的层级可以通过公式 level = floor(log2(index + 1)) 来计算。
  找到节点i和节点j的最近公共祖先的层级，设为level_common = min(level_i, level_j)。
  从根节点开始，根据节点的层级和索引位置，逐层向上遍历，直到找到节点i和节点j的最近公共祖先。
  返回最近公共祖先的值。
  请注意，如果顺序存储结构中节点的索引是从1开始而不是从0开始，则公式计算层级的时候需要调整为 level = floor(log2(index))。
  
  代码：
  
  #include <iostream>
  #include <cmath>
  
  using namespace std;
  
  // 计算节点所在层级
  int getLevel(int index) {
      return floor(log2(index + 1));
  }
  
  // 查找节点i和节点j的最近公共祖先的值
  int findCommonAncestor(int tree[], int i, int j) {
      int index_i = i - 1;  // 将1-based索引调整为0-based索引
      int index_j = j - 1;  // 将1-based索引调整为0-based索引
      int level_i = getLevel(index_i);
      int level_j = getLevel(index_j);
      int level_common = min(level_i, level_j);
  
      // 将节点i和节点j移动到相同的层级
      while (level_i > level_common) {
          index_i = (index_i - 1) / 2;
          level_i--;
      }
  
      while (level_j > level_common) {
          index_j = (index_j - 1) / 2;
          level_j--;
      }
  
      // 在相同的层级上向上遍历，直到找到最近公共祖先
      while (index_i != index_j) {
          index_i = (index_i - 1) / 2;
          index_j = (index_j - 1) / 2;
      }
  
      return tree[index_i];
  }
  
  int main() {
      // 示例用法:
      // 假设二叉树为 [1, 2, 3, 4, 5, 6, 7] (按照层序存储)
      // 树的结构如下:
      //       1
      //      / \
      //     2   3
      //    / \ / \
      //   4  5 6  7
      // 节点4和节点7的最近公共祖先值为1.
      int tree[] = {1, 2, 3, 4, 5, 6, 7};
      int i = 4, j = 7;
      int result = findCommonAncestor(tree, i, j);
      cout << result << endl;  // 输出: 1
  
      return 0;
  }
  ```

  



### 5.2.4 答案







# 5.3 二叉树的遍历与线索二叉树

### 5.3.1 二叉树的遍历

###### ①先序遍历

###### ②中序遍历

###### ③后序遍历

###### ④递归算法与非递归算法的转换

###### ⑤层次遍历

###### ⑥有遍历序列构造二叉树



### 5.3.2 线索二叉树

###### ①线索二叉树的基本概念

###### ②中序线索二叉树的构造

###### ③中序线索二叉树的遍历

###### ④先序线索二叉树和后续线索二叉树



### 5.3.3 课后习题

小题：

- 1
- 3
- 4
- 5
- 14
- 15
- 16
- 18
- 19
- 22
- 23
- 24
- 25
- 26
- 30



大题：

- 1
- 2
- 3
- 4
- 5
- 6
- 7
- 8
- 9
- 10
- 11
- 12
- 13
- 14
- 15
- 16
- 17
- 18
- 19【2014】
- 20【2017】

### 5.3.4 答案







# 5.4 树、森林

### 5.4.1 树的存储结构

###### ①双亲表示法

###### ②孩子表示法

###### ③孩子兄弟表示法



### 5.4.2 树、森林、二叉树的转换

###### 树转化为二叉树的规则：

###### 树转换成二叉树的画法：

###### 森林转化为二叉树的规则：

###### 森林转换成二叉树的画法：

###### 二叉树转换成森林的规则：



### 5.4.3 树和森林的遍历

###### 树的遍历（区别于二叉树的遍历）：

- 先根遍历
- 后根遍历

###### 森林的遍历：

- 先序遍历森林
- 中序遍历森林（部分教材也将森林的中根遍历称为后根遍历）

###### p173 树和森林的遍历与二叉树的对应关系表

######  

### 5.4.4 课后习题（还没做）

小题：

大题：

- 1
- 2
- 3
- 4
- 5
- 6
- 7【2016】

### 5.4.5 答案







# 5.5 树与二叉树的应用

### 5.5.1 哈夫曼树和哈夫曼编码

###### ①哈夫曼树的定义

###### ②哈夫曼树的构造

###### ③哈夫曼编码



### 5.5.2 并查集

###### 并查集的三种操作：



### 5.5.3 课后习题

小题：

- 1

- 7

- 10

  

大题：

- 1
- 2【2012】
- 3【2020】



### 5.5.4 答案





# 归纳总结

# 思维拓展